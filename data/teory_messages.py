THEORY_MSGS = {
    "greeting text": "Привет! Это лучший телеграм бот по языку программирования Python!"
                     " Идеально подойдет как для изучения языка, так и для повторения материала!"
                     " Можно читать теорию простыми словами и с примерами или закреплять знания"
                     " на практике при решении задач!"
                     " Используйте команду /learn чтобы начать!",
    "встроенные функции": "В Python существует множество встроенных функций,"
                          " которые могут быть очень полезными для разработки."
                          " Они облегчают выполнение различных задач и не требуют"
                          " установки дополнительных модулей."
                          " Вот некоторые из наиболее часто используемых:\n"
                          "1. print(): Используется для вывода данных на экран. Например:\n\n"
                          "```python\nprint('Hello, World!')```\n\n"
                          "выводит строку 'Hello, World!'.\n"
                          "2. input(): Позволяет получить ввод от пользователя"
                          " в виде строки. Например:\n\n"
                          "```python\nname = input('Enter your name: ')```\n\n"
                          "сохранит введенное имя в переменной name.\n"
                          "3. len(): Возвращает длину (количество элементов) объектов,"
                          " таких как строки, списки и т.д. Например:\n\n"
                          "```python\nlen('hello')```\n"
                          "вернет 5.\n\n"
                          "4. type(): Возвращает тип объекта. Например:\n\n"
                          "```python\ntype(42)```\n"
                          " вернет <class 'int'>.\n\n"
                          "5. int(), float(), str(): Используются для "
                          "преобразования типов. Например:\n\n"
                          "```python\n"
                          " int('42')\n"
                          "float('3.14')\n"
                          "str(123)```\n\n"
                          "int('42') преобразует строку '42' в целое число,\n"
                          " float('3.14') превращает строку '3.14' в число с плавающей точкой,\n"
                          " а str(123) преобразует число 123 в строку '123'.\n\n"
                          "6. sum(): Возвращает сумму элементов в итерируемом"
                          " объекте, например, списке. Например:\n\n"
                          "```python\nsum([1, 2, 3])```\n"
                          "вернет 6\n\n"
                          "7. min() и max(): Возвращают минимальный и максимальный"
                          " элементы из итерируемого объекта"
                          " соответственно. Например:\n\n"
                          "```python\n"
                          "min([1, 2, 3])\n"
                          "max([1, 2, 3])```\n"
                          "min([1, 2, 3]) вернет 1, а max([1, 2, 3]) вернет 3.\n\n"
                          "8. range(): Генерирует последовательность чисел. Например:\n\n"
                          "```python\nrange(5)```\n"
                          "создаст последовательность от 0 до 4.\n\n"
                          "9. list(), tuple(), set(): Эти функции используются"
                          " для создания списков, кортежей и множеств"
                          " соответственно. Например:\n\n"
                          "```python\nlist((1, 2, 3))```\n"
                          "превратит кортеж в список\n\n"
                          "10. sorted(): Возвращает новую"
                          " отсортированную версию итерируемого"
                          " объекта. Например:\n\n"
                          "```python\nsorted([3, 1, 2])```\n"
                          "вернет [1, 2, 3].\n\n"
                          "11. abs(): Возвращает абсолютное значение числа. Например:\n\n"
                          "```python\nabs(-5)```\n"
                          "вернет 5.\n\n"
                          "12. round(): Округляет число до заданного"
                          " количества десятичных знаков. Например:\n\n"
                          "```python\nround(3.14159, 2)```\n"
                          "вернет 3.14.\n\n"
                          "Эти функции являются основой работы с данными"
                          " в Python и могут использоваться в сочетании друг"
                          " с другом для достижения более сложных целей."
                          " Они просты в использовании и дают вам возможность"
                          " быстро начать программировать на Python.",
    "цикл while": "Цикл while в Python используется для выполнения блока"
                  " кода до тех пор, пока условие остается истинным.\n"
                  " Он полезен в ситуациях, когда количество итераций"
                  " заранее неизвестно и зависит от каких-то условий,"
                  " которые изменяются в процессе выполнения кода.\n"
                  " Вот базовый синтаксис для цикла while: \n\n"
                  " while условие: \n  # Блок кода, который выполняется,"
                  " пока условие истинно\n\n"
                  "Для выхода из цикла можно использовать оператор break,"
                  " который прерывает выполнение цикла,"
                  " даже если условие продолжает оставаться истинным.\n"
                  " Важно помнить про возможность бесконечного цикла,"
                  " когда условие никогда не становится ложным.\n "
                  " В таких случаях программа продолжит выполнение цикла без остановки."
                  " Чтобы этого избежать, следует убедиться, что условия"
                  " в цикле изменяются и, в какой-то момент, станут ложными."
                  " Например:\n\n```python\ncounter = 0\nwhile counter < 5: \n  print(counter)\n  counter += 1```\n\n"
                  "В этом примере переменная counter увеличивается на единицу в каждой итерации."
                  " Когда она достигает значения 5, условие counter < 5"
                  " становится ложным, и цикл while останавливается.\n\n"
                  "Оператор continue можно использовать для пропуска"
                  " текущей итерации и перехода к следующей."
                  " Например, чтобы пропустить печать числа 3:"
                  "\n\n```python\ncounter = 0\nwhile counter < 5: "
                  "\n  counter += 1\n  if counter == 3:\n    "
                  "continue\n  print(counter)```\n\nВ результате будут "
                  "напечатаны числа 1, 2, 4 и 5, поскольку 3 было "
                  "пропущено за счет оператора continue.",
    "цикл for": "Цикл for в Python используется для перебора"
                " (итерации) элементов любой последовательности,"
                " например, списка, строки или диапазона чисел.\n\n"
                "1. итерация по списку:\n"
                "```python\n"
                "fruits = ['яблоко', 'банан', 'вишня']\n"
                "for fruit in fruits:\n  "
                "print(fruit)```\n"
                "Этот цикл перебирает каждый элемент списка fruits и выводит его.\n\n"
                "2. Итерация по строке:\n"
                "```python\n"
                "for char in 'hello':\n  "
                "print(char)```\n"
                "Этот цикл перебирает каждый символ строки 'hello' и выводит его по одному.\n\n"
                "3. Использование функции range:\n"
                "```python\n"
                "for i in range(5):\n  "
                "print(i)```\n"
                "Функция range генерирует последовательность от 0 до 4 и цикл for перебирает их.\n\n"
                "4. Итерация по словарю:\n"
                "```python\n"
                "dict = {'name': 'Alice', 'age': 25}\n"
                "for key in dict:\n  "
                "print(key, dict[key])```\n"
                "Цикл перебирает ключи словаря dict и выводит каждый ключ и соответствующее ему значение.",
    "методы списков": "Основные методы списков: \n\n"
                      "1. append(x)\n"
                      "Добавляет элемент x в конец списка.\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "lst.append(4)\n"
                      "print(lst)\n"
                      "# Результат: [1, 2, 3, 4]```\n\n"
                      "2 . extend(iterable)\n"
                      "Расширяет список добавляя все элементы из переданного итерируемого объекта.\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "lst.extend([4, 5])\n"
                      "print(my_list)\n"
                      "# Результат: [1, 2, 3, 4, 5]```\n\n"
                      "3. insert(i, x)\n"
                      "Вставляет элемент x на позицию i.\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "lst.insert(1, 4)\n"
                      "print(lst)\n"
                      "# Результат: [1, 4, 2, 3]```\n\n"
                      "4. remove(x)\n"
                      "Удаляет первый элемент в списке, имеющий значение x.\n"
                      "```python\n"
                      "lst = [1, 2, 3, 2]\n"
                      "lst.remove(2)\n"
                      "print(lst)\n"
                      "# Результат: [1, 3, 2]```\n\n"
                      "5. pop([i])\n"
                      "Удаляет и возвращает элемент на позиции i (по умолчанию последний элемент).\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "element = lst.pop()\n"
                      "print(element)  # Результат: 3\n"
                      "print(lst)  # Результат: [1, 2]```\n\n"
                      "6. clear()\n"
                      "Удаляет все элементы из списка.\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "lst.clear()\n"
                      "print(lst)  # Результат: []```\n\n"
                      "7. index(x, [start[, end]])\n"
                      "Возвращает индекс первого элемента со значением x,"
                      " начиная поиск с позиции start и заканчивая end.\n"
                      "```python\n"
                      "lst = [1, 2, 3, 2]\n"
                      "print(lst.index(2)) # Результат: 1\n"
                      "print(lst.index(2, 2)) # Результат: 3```\n\n"
                      "8. count(x)\n"
                      "Возвращает количество элементов в списке, равных x.\n"
                      "```python\n"
                      "lst = [1, 2, 2, 3]\n"
                      "print(lst.count(2))  # Результат: 2```\n\n"
                      "9. sort(key=None, reverse=False)\n"
                      "Сортирует элементы списка на месте"
                      "(значение key может быть функцией, по которой"
                      "производится сортировка, reverse - если True,"
                      " сортировка происходит в обратном порядке).\n"
                      "```python\n"
                      "lst = [3, 1, 2]\n"
                      "lst.sort()\n"
                      "print(lst)  # Результат: [1, 2, 3]\n"
                      "lst.sort(reverse=True)\n"
                      "print(lst)  # Результат: [3, 2, 1]```\n\n"
                      "10. reverse()\n"
                      "Разворачивает список на месте.\n"
                      "```python\n"
                      "lst = [1, 2, 3]\n"
                      "lst.reverse()\n"
                      "print(lst)  # Результат: [3, 2, 1]```\n\n"
                      "11. copy()\n"
                      "Возвращает поверхностную копию списка.\n"
                      "```python\n"
                      "lst = [1, 2, 3]"
                      "lst2 = lst.copy()\n"
                      "print(lst2)  # Результат: [1, 2, 3]```",
    "методы строк": "Основные методы строк:\n\n"
                    "1. s.find(s2)\n"
                    "Индекс начала первого или последнего"
                    "вхождения подстроки s2 в s (вернет -1, если s2 not in s)\n"
                    "```python\n"
                    "text = 'hello world'\n"
                    "result = text.find('world')\n"
                    "print(result)  # Результат: 6```\n\n"
                    "2. strip(chars=None)\n"
                    "Удаляет указанные символы chars (по умолчанию пробелы) с начала и конца строки.\n"
                    "```python\n"
                    "text = '  hello world  '\n"
                    "result = text.strip()\n"
                    "print(result)  # Результат: 'hello world'```\n\n"
                    "3. lower()\n"
                    "Возвращает копию строки, где все символы переведены в нижний регистр.\n"
                    "```python\n"
                    "text = 'Hello World'\n"
                    "result = text.lower()\n"
                    "print(result)  # Результат: 'hello world'```\n\n"
                    "4. upper()\n"
                    "Возвращает копию строки, где все символы переведены в верхний регистр.\n"
                    "```python\n"
                    "text = 'Hello World'\n"
                    "result = text.upper()\n"
                    "print(result)  # Результат: 'HELLO WORLD'```\n\n"
                    "5. split(sep=None, maxsplit=-1)\n"
                    "Разделяет строку по разделителю sep. Возвращает список подстрок.\n"
                    "```python\n"
                    "text = 'hello world'\n"
                    "result = text.split(' ')\n"
                    "print(result)  # Результат: ['hello', 'world']```\n\n"
                    "6. join(iterable)\n"
                    "Возвращает строку, объединяющую все элементы iterable,"
                    " разделенные строкой, к которой применяется метод.\n"
                    "```python\n"
                    "separator = '-'\n"
                    "sequence = ['a', 'b', 'c']\n"
                    "result = separator.join(sequence)\n"
                    "print(result)  # Результат: 'a-b-c'```\n\n"
                    "7. format()\n"
                    "Форматирует строку, используя указанные аргументы и именованные параметры.\n"
                    "```python\n"
                    "text = 'Hello, {}!'\n"
                    "result = text.format('Alice')\n"
                    "print(result)  # Результат: 'Hello, Alice!'```\n\n"
                    "8. startswith(prefix, start=0, end=len(string))\n"
                    "Возвращает True, если строка начинается с указанного префикса prefix.\n"
                    "```python\n"
                    "text = 'hello world'\n"
                    "result = text.startswith('hello')\n"
                    "print(result)  # Результат: True```\n\n"
                    "9. endswith(suffix, start=0, end=len(string))\n"
                    "Возвращает True, если строка заканчивается указанным суффиксом suffix.\n"
                    "```python\n"
                    "text = 'hello world'\n"
                    "result = text.endswith('world')\n"
                    "print(result)  # Результат: True```\n\n"
                    "10. s.isdigit() s.isalpha() s.isalnum()\n"
                    "Проверка, что в строке s все символы цифры, "
                    "буквы (включая кириллические), "
                    "цифры или буквы соответственно\n"
                    "```python\n"
                    "'100'.isdigit()\n"
                    "'abc'.isalpha()\n"
                    "'E315'.isalnum()```\n\n"
                    "11. s.replace(s2, s3)\n"
                    "строка s, в которой все неперекрывающиеся вхождения s2 заменены на s3 "
                    "Есть необязательный третий параметр, с помощью которого"
                    " можно указать, сколько раз производить замену\n"
                    "```python\n"
                    "text = 'hello world'\n"
                    "result = text.replace('world', 'Python')\n"
                    "print(result)  # Результат: 'hello Python'```\n\n"
                    "12. list(s)\n"
                    "Список символов из строки строки s\n"
                    "```python\n"
                    "print(list('Привет'))\n"
                    "# результат ['П', 'р', 'и', 'в', 'е', 'т']```\n\n"
                    "13. str(x)\n"
                    "Представить любой объект x в виде строки\n"
                    "```python\n"
                    "print(str(25))\n"
                    "# результат '25'```",
    "словари": "Словари в Python — это удобная структура данных,"
               " позволяющая хранить пары 'ключ-значение'."
               " Они часто используются из-за их эффективности в операциях поиска,"
               " добавления и удаления элементов."
               " Основные методы:\n\n"
               "1. dict.get(key[, default])\n"
               "Возвращает значение по указанному ключу. Если ключ не найден, возвращает default (по умолчанию None).\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "grade = student-grades.get('Alice')\n"
               "print(grade)  # Вывод: 85\n"
               "no-grade = student-grades.get('Charlie', 'No grade')\n"
               "print(no-grade)  # Вывод: No grade```\n\n"
               "2. dict.keys()\n"
               "Возвращает новый объект представления, отображающий все ключи.\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "keys = student-grades.keys()\n"
               "print(keys)  # Вывод: dict-keys(['Alice', 'Bob'])```\n\n"
               "3. dict.values()\n"
               "Возвращает новый объект представления, отображающий все значения.\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "values = student-grades.values()\n"
               "print(values)  # Вывод: dict-values([85, 92])```\n\n"
               "4. dict.items()\n"
               "Возвращает новый объект представления всех пар (ключ, значение).\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "items = student-grades.items()\n"
               "print(items)  # Вывод: dict-items([('Alice', 85), ('Bob', 92)])```\n\n"
               "5. dict.update([other])\n"
               "Обновляет словарь, добавляя пары 'ключ-значение' "
               "из другого словаря или итерируемого объекта с парами.\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "new-grades = {'Charlie': 88, 'Bob': 95}\n"
               "student-grades.update(new-grades)\n"
               "print(student-grades)  # Вывод: {'Alice': 85, 'Bob': 95, 'Charlie': 88}```\n\n"
               "6. dict.pop(key[, default])\n"
               "Удаляет ключ и возвращает его значение. Если ключ не найден - возвращает default; "
               "если default не указано, вызывает KeyError.\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "bob-grade = student-grades.pop('Bob')\n"
               "print(bob-grade)  # Вывод: 92\n"
               "print(student-grades)  # Вывод: {'Alice': 85}```\n\n"
               "7. dict.popitem()\n"
               "Удаляет и возвращает пару (ключ, значение). Если словарь пуст, выдает KeyError.\n"
               "```python\n"
               "student-grades = {'Alice': 85, 'Bob': 92}\n"
               "item = student-grades.popitem()\n"
               "print(item)  # Вывод: ('Bob', 92)\n"
               "print(student-grades)  # Вывод: {'Alice': 85}```\n\n"
               "8. dict.setdefault(key[, default])\n"
               "Возвращает значение, соответствующее ключу. Если ключ отсутствует,"
               " добавляет ключ со значением default (по умолчанию None).\n"
               "```python\n"
               "student-grades = {'Alice': 85}\n"
               "alice-grade = student-grades.setdefault('Alice', 90)\n"
               "print(alice-grade)  # Вывод: 85\n"
               "charlie-grade = student-grades.setdefault('Charlie', 75)\n"
               "print(student-grades)  # Вывод: {'Alice': 85, 'Charlie': 75}```\n\n",
    "множества": "Множества в Python (set) — это неупорядоченные коллекции уникальных элементов."
                 " Они полезны в ситуациях, где необходимо исключить дублирование или производить"
                 " быстрые операции проверки наличия.\n"
                 "Основные методы:\n\n"
                 "1. add(elem)\n"
                 "Добавляет элемент в множество.\n"
                 "```python\n"
                 "my-set = {1, 2, 3}\n"
                 "my-set.add(4)\n"
                 "print(my-set)  # Вывод: {1, 2, 3, 4}```\n\n"
                 "2. remove(elem)\n"
                 "Удаляет элемент из множества. Если элемент не найден, вызывает KeyError.\n"
                 "```python\n"
                 "my-set = {1, 2, 3}\n"
                 "my-set.remove(2)\n"
                 "print(my-set)  # Вывод: {1, 3}```\n\n"
                 "Замороженные множества (frozenset) в Python — это неизменяемые (immutable) версии"
                 " обычных множеств (set). Они полезны в ситуациях, где необходимо"
                 " гарантировать, что содержимое множества не будет изменено, например,"
                 " когда множество требуется использовать в качестве ключа в словаре.\n"
                 "Операции для frozenset аналогичны операциям с set, но нельзя изменять содержимое.Например:\n\n"
                 "метод union()\n"
                 "Возвращает объединение множеств.\n"
                 "```python\n"
                 "a = frozenset([1, 2, 3])\n"
                 "b = {3, 4, 5}\n"
                 "result = a.union(b)\n"
                 "print(result)  # Вывод: frozenset({1, 2, 3, 4, 5})```",
    "кортежи": "Кортежи (tuples) в Python — это неизменяемые последовательности,"
               " используемые для хранения коллекций элементов разного типа."
               " Они подобны спискам, но имеют ключевое отличие: кортежи нельзя изменять после создания.\n"
               "Методы кортежей аналогичны методам списков, которые не могут изменять содержимое. Например:\n\n"
               "метод count(value)\n"
               "Возвращает количество вхождений элемента в кортеж.\n"
               "```python\n"
               "my-tuple = (1, 2, 3, 2, 2, 4)\n"
               "print(my-tuple.count(2))  # Вывод: 3```\n\n"
               "метод tuple(iterable)\n"
               "Преобразует итерируемый объект в кортеж.\n"
               "```python\n"
               "my-list = [1, 2, 3]\n"
               "my-tuple = tuple(my-list)\n"
               "print(my-tuple)  # Вывод: (1, 2, 3)```\n",
    "лямбда-функции": "Lambda-функция в Python — это анонимная функция, которая"
                      " определяется с помощью ключевого слова lambda."
                      " Она может принимать любое количество аргументов,"
                      " но может содержать только одно выражение. Основное применение"
                      " lambda-функций — это создание небольших функций на лету,"
                      " особенно в случаях, когда вы не хотите определять полноценную функцию с помощью def.\n"
                      "Примеры использования:\n\n"
                      "1. Простая lambda-функция:\n"
                      "```python\n"
                      "# Функция, которая возвращает квадрат числа\n"
                      "square = lambda x: x ** 2\n"
                      "print(square(5))  # Вывод: 25```\n\n"
                      "2. Использование с функцией map:\n"
                      "```pyhon\n"
                      "numbers = [1, 2, 3, 4, 5]\n"
                      "squared-numbers = list(map(lambda x: x ** 2, numbers))\n"
                      "print(squared-numbers)  # Вывод: [1, 4, 9, 16, 25]```\n\n"
                      "3. Использование с функцией filter:\n"
                      "```python\n"
                      "numbers = [1, 2, 3, 4, 5]\n"
                      "even-numbers = list(filter(lambda x: x % 2 == 0, numbers))\n"
                      "print(even-numbers)  # Вывод: [2, 4]```\n\n"
                      "4. Использование с функцией sorted:\n"
                      "```python\n"
                      "points = [(1, 2), (3, 1), (5, -1)]\n"
                      "sorted_points = sorted(points, key=lambda point: point[1])\n"
                      "print(sorted_points)  # Вывод: [(5, -1), (3, 1), (1, 2)]```",
    "map, sorted, filter": "В Python функции map, sorted и filter используются для обработки и манипуляции данных.\n\n"
                           "1. map()\n"
                           "Функция map используется для применения заданной функции"
                           " к каждому элементу итерируемого объекта и возвращает итератор с результатами.\n"
                           "# Функция, которая возвращает квадрат числа\n"
                           "```python\n"
                           "def square(x):\n    "
                           "return x ** 2\n"
                           "numbers = [1, 2, 3, 4, 5]\n"
                           "squared-numbers = map(square, numbers)\n"
                           "print(list(squared-numbers))  # Вывод: [1, 4, 9, 16, 25]```\n\n"
                           "2. sorted()\n"
                           "Функция sorted возвращает новый отсортированный список из элементов"
                           " итерируемого объекта. Она не изменяет исходный итерируемый объект.\n"
                           "```python\n"
                           "numbers = [5, 2, 3, 1, 4]\n"
                           "sorted-numbers = sorted(numbers)\n"
                           "print(sorted-numbers)  # Вывод: [1, 2, 3, 4, 5]```\n\n"
                           "3. filter()\n"
                           "Функция filter создаёт итератор из элементов итерируемого объекта,"
                           " для которых заданная функция возвращает True.\n"
                           "```python\n"
                           "# Функция, которая проверяет, является ли число чётным\n"
                           "def it-even(x):\n    "
                           "return x % 2 == 0\n"
                           "numbers = [1, 2, 3, 4, 5, 6]\n"
                           "even-numbers = filter(it-even, numbers)\n"
                           "print(list(even_numbers))  # Вывод: [2, 4, 6]```",
    "рекурсия": "Рекурсивные функции — это функции, которые вызывают сами себя в процессе выполнения."
                " Они часто используются для решения задач, которые естественным"
                " образом можно разбить на несколько аналогичных подзадач.\n\n"
                "Базовый случай — это условие, при котором рекурсивный вызов прекращается, предотвращая"
                " бесконечную рекурсию. Он представляет собой самый простой подвариант задачи,"
                " который может быть решён без дальнейших рекурсивных вызовов.\n\n"
                "Рекурсивный случай — это условие, при котором функция продолжает вызывать"
                " саму себя, делая шаги к базовому случаю.\n\n"
                "Стек вызовов — это структура данных, которая управляет последовательностью вызова функций."
                " Каждый вызов функции добавляет новый фрейм в стек, и когда"
                " функция возвращает значение, её фрейм удаляется из стека.\n\n"
                "1. Вычисление факториала числа:"
                "```python\n"
                "def factorial(n):\n  "
                "if n == 0: # базовый случай\n    "
                "return 1\n  "
                "else: # рекурсивный случай\n    "
                "return n * factorial(n-1)\n"
                "print(factorial(5))  # Вывод: 120```\n\n"
                "2. Числа Фибоначчи:"
                "```python\n"
                "def fibonacci(n):\n  "
                "if n == 0:\n    "
                "return 0\n  "
                "elif n == 1:\n    "
                "return 1\n  "
                "else:\n    "
                "return fibonacci(n-1) + fibonacci(n-2)\n"
                "print(fibonacci(6))  # Вывод: 8```\n\n"
                "3. Поиск в двоичном дереве (обход дерева):\n\n"
                "Представьте, что у вас есть структура данных дерева, где каждая"
                " вершина может иметь две дочерние вершины (левую и правую)."
                " Один из способов пройтись по всему дереву — это использовать"
                " рекурсивный вызов функции для каждой вершины.\n"
                "```python\n"
                "class Node:\n  "
                "def __init__(self, value):\n    "
                "self.value = value\n    "
                "self.left = None\n    "
                "self.right = None\n\n"
                "def inorder_traversal(node):\n  "
                "if node is not None:\n    "
                "inorder_traversal(node.left)\n    "
                "print(node.value)\n    "
                "inorder_traversal(node.right)\n\n"
                "# Пример использования:\n"
                "root = Node(1)\n"
                "root.left = Node(2)\n"
                "root.right = Node(3)\n"
                "root.left.left = Node(4)\n"
                "root.left.right = Node(5)\n"
                "inorder_traversal(root)\n"
                "# Вывод: 4 2 5 1 3```",
    "потоковый ввод stdin": "sys.stdin в Python — это стандартный поток ввода, который позволяет"
                            " программе получать данные из стандартного ввода (обычно это клавиатура"
                            " или данные, перенаправленные из файла). Это особенно полезно"
                            " для работы с данными, которые поступают в программу во время её выполнения.\n\n"
                            "1. Чтение строки:\n"
                            "```python\n"
                            "line = sys.stdin.readline()\n"
                            "print(line)```\n\n"
                            "2. Чтение всех строк:\n"
                            "```python\n"
                            "all-lines = sys.stdin.read()\n"
                            "print(all-lines)```\n\n"
                            "3. Итерация по строкам:\n"
                            "```python\n"
                            "for line in sys.stdin:\n    "
                            "print(line.strip())```\n\n"
                            "Простой пример, который читает строки из стандартного ввода и выводит их в обратном порядке:\n"
                            "```python\n"
                            "import sys\n\n"
                            "lines = []\n\n"
                            "# Читаем строки до конца ввода\n"
                            "for line in sys.stdin:\n    "
                            "lines.append(line.strip())\n"
                            "# Выводим строки в обратном порядке\n"
                            "for line in reversed(lines):\n    "
                            "print(line)```",
    "декораторы": "Декораторы в Python — это специальные функции или методы, которые позволяют"
                  " модифицировать или расширять функциональность других функций или методов"
                  " без изменения их кода. Они используются для оборачивания функций или методов,"
                  " чтобы добавить к ним дополнительное поведение.\n\n"
                  "1. Простой декоратор:\n"
                  "Этот декоратор просто выводит сообщение перед и после выполнения основной функции.\n"
                  "```python\n"
                  "def simple_decorator(func):\n    "
                  "def wrapper():\n        "
                  "print('Перед вызовом функции.')\n        "
                  "func()\n        "
                  "print('После вызова функции.')\n    "
                  "return wrapper\n\n"
                  "@simple_decorator\n"
                  "def say_hello():\n    "
                  "print('Привет!')\n\n"
                  "say_hello()\n"
                  "# Вывод:\n"
                  "# Перед вызовом функции.\n"
                  "# Привет!\n"
                  "# После вызова функции.```\n\n"
                  "2.Класс-декоратор:"
                  "```python\n"
                  "class ClassDecorator:\n    "
                  "def __init__(self, func):\n        "
                  "self.func = func\n    "
                  "def __call__(self, *args, **kwargs):\n        "
                  "print('Класс-Декоратор: Перед вызовом функции.')\n        "
                  "result = self.func(*args, **kwargs)\n        "
                  "print('Класс-Декоратор: После вызова функции.')\n        "
                  "return result\n"
                  "@ClassDecorator\n"
                  "def greet(name):\n    "
                  "print(f'Привет, {name}!')\n\n"
                  "greet('Мир')\n"
                  "# Вывод:\n"
                  "# Класс-Декоратор: Перед вызовом функции.\n"
                  "# Привет, Мир!\n"
                  "# Класс-Декоратор: После вызова функции.```",
    "datetime": "Библиотека datetime в Python предоставляет классы для работы с датами и временем."
                " Наиболее часто используемые классы и методы включают date, time, datetime и timedelta.\n\n"
                "1. класс date\n"
                "Этот класс используется для работы с временем.\n"
                "- today(): Возвращает текущую дату.\n"
                "- fromisoformat(date-string): Создает объект даты из строки в формате YYYY-MM-DD.\n"
                "```python\n"
                "from datetime import date\n\n"
                "# Текущая дата\n"
                "today = date.today()\n"
                "print('Сегодняшняя дата:', today)\n\n"
                "# Создание даты из строки\n"
                "date-from-string = date.fromisoformat('2023-10-01')\n"
                "print('Дата из строки:', date-from-string)```\n\n"
                "2. класс datetime\n"
                "Этот класс объединяет дату и время.\n"
                "- now(): Возвращает текущие дату и время.\n"
                "- strftime(format): Возвращает строку datetime в заданном формате.\n"
                "- fromisoformat(datetime-string): Создает объект datetime из строки в формате YYYY-MM-HH:MM:SS."
                "```python\n"
                "from datetime import datetime\n\n"
                "# Текущие дата и время\n"
                "now = datetime.now()\n"
                "print('Сейчас:', now)\n\n"
                "# Форматирование datetime\n"
                "formatted-datetime = now.strftime('%Y-%m-%d %H:%M:%S')\n"
                "print('Форматированный datetime:', formatted_datetime)\n\n"
                "# Создание datetime из строки\n"
                "datetime-from-string = datetime.fromisoformat('2023-10-01T12:34:56')\n"
                "print('Datetime из строки:', datetime-from-string)```\n\n"
                "3. класс timedelta\n"
                "Этот класс используется для представления разницы между"
                " двумя значениями даты, времени или datetime.\n"
                "- days, seconds, microseconds: Атрибуты для доступа к различным компонентам разницы.\n"
                "- Операции сложения и вычитания.\n"
                "```python\n"
                "from datetime import datetime, timedelta\n\n"
                "# Создание разницы во времени\n"
                "delta = timedelta(days=2, hours=3, minutes=15)\n"
                "print('Разница во времени:', delta)\n\n"
                "# Текущие дата и время\n"
                "now = datetime.now()\n\n"
                "# Добавление разницы к текущей дате и времени\n"
                "future = now + delta\n"
                "print('Будущая дата и время:', future)\n\n"
                "# Вычитание разницы из текущей даты и времени\n"
                "past = now - delta\n"
                "print('Прошлая дата и время:', past)```",
    "random": "Модуль random в Python предоставляет функции для генерации случайных чисел"
              " и выполнения различных операций со случайностью."
              " Ниже приведены часто используемые методы с примерами.\n\n"
              "1. randint(a, b)\n"
              "Возвращает случайное целое число N, такое что a <= N <= b.\n"
              "```python\n"
              "import random\n\n"
              "random-integer = random.randint(1, 10)\n"
              "print('Случайное целое число от 1 до 10:', random-integer)```\n\n"
              "2. choice(lst)\n"
              "Возвращает случайный элемент из непустой последовательности lst.\n"
              "```python\n"
              "import random\n\n"
              "items = ['apple', 'banana', 'orange']\n"
              "random-item = random.choice(items)\n"
              "print('Случайный элемент из списка:', random-item)```\n\n"
              "3. shuffle(lst)\n"
              "Перемешивает последовательность lst.\n"
              "```python\n"
              "import random\n\n"
              "items = [1, 2, 3, 4, 5]\n"
              "random.shuffle(items)\n"
              "print('Перемешанный список:', items)```\n\n"
              "4. sample(population, k)\n"
              "Возвращает список длины k с уникальными элементами, выбранными из population.\n"
              "```python\n"
              "import random\n\n"
              "items = range(1, 11)\n"
              "sampled-items = random.sample(items, 3)\n"
              "print('Три случайных элемента из диапазона от 1 до 10:', sampled-items)```\n\n"
              "5. randrange(start, stop, step)\n"
              "Возвращает случайное целое число из диапазона start до stop (не включая stop) с шагом step.\n"
              "```python\n"
              "import random\n\n"
              "random-range = random.randrange(1, 10, 2)\n"
              "print('Случайное число от 1 до 10 с шагом 2:', random_range)```",
    "numpy": "NumPy (Numerical Python) — это библиотека для языка программирования Python,"
             " предназначенная для работы с многомерными массивами и матрицами,"
             " а также для выполнения различных вычислительных операций с высокой производительностью."
             " Она является фундаментальной библиотекой для научных вычислений в Python и часто используется"
             " в связке с другими библиотеками, такими как SciPy, Pandas, Matplotlib и др.\n\n"
             "1. Создание массивов\n"
             "```python\n"
             "import numpy as np\n\n"
             "# Создание массива из списка\n"
             "array = np.array([1, 2, 3, 4])\n\n"
             "# Создание двумерного массива (матрицы)\n"
             "matrix = np.array([[1, 2], [3, 4]])```\n\n"
             "2. Функции для создания массивов\n"
             "```python\n"
             "# Массив из нулей\n"
             "zeros = np.zeros((3, 3))\n\n"
             "# Массив из единиц\n"
             "ones = np.ones((2, 2))\n\n"
             "# Массив с последовательностью чисел (аналог range)\n"
             "arange = np.arange(0, 10, 2)\n\n"
             "# Линейно разделенные числа\n"
             "linspace = np.linspace(0, 1, 5)```\n\n"
             "3. Основные операции\n"
             "```python\n"
             "# Сложение массивов\n"
             "a = np.array([1, 2, 3])\n"
             "b = np.array([4, 5, 6])\n"
             "result = a + b  # [5, 7, 9]\n\n"
             "# Покомпонентное умножение\n"
             "mult = a * b  # [4, 10, 18]\n\n"
             "# Матрица умножения\n"
             "matrix_mult = np.dot(a, b)  # 1*4 + 2*5 + 3*6 = 32\n\n"
             "# Транспонирование матрицы\n"
             "transposed = matrix.T```\n\n"
             "4. Статистические операции\n"
             "```python\n"
             "# Среднее значение\n"
             "mean = np.mean(array)\n\n"
             "# Медиана\n"
             "median = np.median(array)\n\n"
             "# Стандартное отклонение\n"
             "std_dev = np.std(array)```\n\n"
             "5. Работа с индексами\n"
             "```python\n"
             "# Максимальное значение и его индекс\n"
             "max_value = np.max(array)\n"
             "max_index = np.argmax(array)\n\n"
             "# Условная индексация\n"
             "condition = array > 2  # [False, False, True, True]\n"
             "filtered_array = array[condition]  # [3, 4]```\n\n"
             "6. Случайные числа\n"
             "```pyhon\n"
             "# Генерация случайных чисел от 0 до 1\n"
             "random_numbers = np.random.rand(5)\n\n"
             "# Генерация случайных целых чисел\n"
             "random_integers = np.random.randint(1, 10, size=(3, 3))```",
    "pillow": "Pillow — это мощная библиотека Python для работы с изображениями."
              " Она является улучшенной и расширенной версией библиотеки PIL (Python Imaging Library)."
              " С помощью Pillow можно выполнять множество операций с изображениями, включая загрузку,"
              " сохранение, обработку и преобразование форматов.\n\n"
              "1. Загрузка и сохранение изображений\n"
              "```python\n"
              "   from PIL import Image\n\n"
              "# Открытие изображения\n"
              "image = Image.open('example.jpg')\n\n"
              "# Сохранение изображения\n"
              "image.save('output.png')```\n\n"
              "2. Отображение изображений\n"
              "```python\n"
              "image.show()```\n\n"
              "3. Изменение размера и обрезка изображения\n"
              "```python\n"
              "# Изменение размера\n"
              "resized_image = image.resize((300, 300))\n\n"
              "# Обрезка изображения (left, upper, right, lower)\n"
              "cropped_image = image.crop((50, 50, 200, 200))```\n\n"
              "4. Поворот и транспонирование\n"
              "```python\n"
              "# Поворот на 45 градусов\n"
              "rotated_image = image.rotate(45)\n\n"
              "# Отражение по горизонтали\n"
              "flipped_image = image.transpose(Image.FLIP_LEFT_RIGHT)```\n\n"
              "5. Применение фильтров\n"
              "```python\n"
              "from PIL import ImageFilter\n\n"
              "# Размытие изображения\n"
              "blurred_image = image.filter(ImageFilter.BLUR)\n\n"
              "# Увеличение резкости\n"
              "sharpened_image = image.filter(ImageFilter.SHARPEN)```\n\n"
              "6. Работа с альфа-каналом и прозрачностью\n"
              "```python\n"
              "# Конвертация изображения в формат с альфа-каналом (RGBA)\n"
              "rgba_image = image.convert('RGBA')```\n\n"
              "7. Работа с текстом\n"
              "```python\n"
              "from PIL import ImageDraw, ImageFont\n\n"
              "# Создание рисунка для редактирования изображения\n"
              "draw = ImageDraw.Draw(image)\n\n"
              "# Настройка шрифта\n"
              "font = ImageFont.truetype('arial.ttf', 36)\n\n"
              "# Добавление текста на изображение\n"
              "draw.text((50, 50), 'Hello, Pillow!', (255, 255, 255), font=font)```\n\n"
              "8. Создание изображений с нуля\n"
              "```python\n"
              "# Создание нового изображения (ширина, высота, цветовой режим)\n"
              "new_image = Image.new('RGB', (400, 400), (255, 255, 255))\n\n"
              "# Рисование на новом изображении\n"
              "draw_new = ImageDraw.Draw(new_image)\n"
              "draw_new.rectangle([50, 50, 350, 350], outline=(0, 0, 255), width=5)```",
    "полиморфизм": "Полиморфизм в Python — это концепция объектно-ориентированного программирования,"
                   " которая позволяет различным классам иметь методы с одинаковыми именами,"
                   " но реализованными по-разному. Это упрощает работу с объектами различных типов,"
                   " позволяя использовать один и тот же интерфейс.\n\n"
                   "Представим, что у нас есть два класса, Cat и Dog, каждый из которых"
                   " имеет метод speak(), но реализует его по-разному.\n"
                   "```python\n"
                   "class Cat:\n    "
                   "def speak(self):\n        "
                   "return 'Meow'\n\n"
                   "class Dog:\n    "
                   "def speak(self):\n        "
                   "return 'Woof'\n\n"
                   "def animal_sound(animal):\n    "
                   "print(animal.speak())\n\n"
                   "cat = Cat()\n"
                   "dog = Dog()\n\n"
                   "animal_sound(cat)  # Вывод: Meow\n"
                   "animal_sound(dog)  # Вывод: Woof```\n\n"
                   "В этом примере функция animal_sound принимает объект animal и вызывает его метод speak()."
                   " Несмотря на то, что объекты cat и dog относятся к разным классам, они оба имеют метод speak(),"
                   " что позволяет им использовать один и тот же интерфейс в функции animal_sound."
                   " Это и есть полиморфизм, который позволяет работать с"
                   " различными типами объектов единообразно.",
    "наследование": "Наследование в Python — это концепция объектно-ориентированного программирования, которая"
                    " позволяет одному классу (наследнику) унаследовать атрибуты и методы другого класса (родителя)."
                    " Это обеспечивает повторное использование кода и упрощает создание новых классов.\n\n"
                    "Предположим, у нас есть базовый класс Animal, и мы хотим создать класс Dog,"
                    " который унаследует атрибуты и методы класса Animal.\n"
                    "```python\n"
                    "class Animal:\n    "
                    "def __init__(self, name):\n        "
                    "self.name = name\n\n    "
                    "def speak(self):\n        "
                    "raise NotImplementedError('Subclass must implement abstract method')\n\n"
                    "class Dog(Animal):\n    "
                    "def speak(self):\n        "
                    "return f'{self.name} says Woof'\n\n"
                    "dog = Dog('Buddy')\n"
                    "print(dog.speak())  # Вывод: Buddy says Woof```\n\n"
                    "В этом примере:\n"
                    "- Класс Animal является родительским классом, который определяет общий интерфейс и атрибут name.\n"
                    "- Класс Dog является наследником и переопределяет метод speak(), добавляя свою реализацию.\n\n"
                    "Класс Dog унаследовал конструктор и атрибут name класса Animal, но реализовал"
                    " свою версию метода speak(), что демонстрирует принцип наследования в Python.",
    "магические методы": "Магические методы в Python, также известные как дандер-методы"
                         " (от 'double underscore'), позволяют разработчикам определять и изменять"
                         " поведение объектов в определённых контекстах. Они начинаются"
                         " и заканчиваются двумя подчеркиваниями"
                         " и предоставляют способ взаимодействия с встроенными функциями и операторами.\n\n"
                         "1. __str__ и __repr__\n"
                         "- __str__ возвращает читаемую строку, представляющую объект.\n"
                         " Вызывается при использовании функции print.\n"
                         "- __repr__ возвращает строку, которая должна дать точное представление объекта,"
                         " если возможно. Вызывается функцией repr.\n"
                         "```python\n"
                         "class MyClass:\n    "
                         "def __str__(self):\n        "
                         "return 'Человекочитаемое представление'\n\n    "
                         "def __repr__(self):\n        "
                         "return 'MyClass()'```\n\n"
                         "2.  __getitem__, __setitem__, __delitem__\n"
                         "Позволяют работать с объектами как со списками или словарями.\n"
                         "```python\n"
                         "class MyDict:\n    "
                         "def __getitem__(self, key):\n        "
                         "return f'Получено значение для {key}'\n\n    "
                         "def __setitem__(self, key, value):\n        "
                         "print(f'Установлено значение {value} для {key}')\n\n    "
                         "def __delitem__(self, key):\n        "
                         "print(f'Удалено значение для {key}')```\n\n"
                         "3. __eq__, __ne__, __lt__, __le__, __gt__, __ge__\n"
                         "Методы для сравнения объектов. Каждый метод соответствует определённому"
                         " оператору сравнения (==, !=, <, <=, >, >=).\n"
                         "```python\n"
                         "class MyComparable:\n    "
                         "def __eq__(self, other):\n        "
                         "return self.value == other.value```\n\n"
                         "4. __add__, __sub__, __mul__, и т.д.\n"
                         "Методы для арифметических операций.\n"
                         "```python\n"
                         "class MyNumber:\n    "
                         "def __add__(self, other):\n        "
                         "return self.value + other.value```\n\n"
                         "Эти методы предоставляют мощный инструмент для создания настраиваемых классов,"
                         " которые могут вести себя так, как требуется в рамках стандартных операций Python.",
    "бинарный поиск": "Бинарный поиск - это алгоритм для нахождения позиции целевого элемента"
                      " в отсортированном массиве или списке. Принцип работы бинарного поиска"
                      " заключается в последовательном делении отрезка поиска пополам и исключении той половины,"
                      " в которой целевой элемент не может находиться. Этот метод значительно ускоряет"
                      " поиск по сравнению с линейным поиском, но требует, чтобы массив был отсортирован.\n\n"
                      "Принцип работы:\n"
                      "1. Определите начальные границы: левую (начало массива) и правую (конец массива).\n"
                      "2. Найдите средний элемент между текущими левым и правым индексами.\n"
                      "3. Сравните целевой элемент с центральным элементом\n"
                      "- Если центральный элемент равен целевому, возвращаем его индекс.\n"
                      "- Если целевой элемент меньше центрального элемента, продолжаем поиск в левой половине.\n"
                      "- Если целевой элемент больше центрального элемента, продолжаем поиск в правой половине.\n"
                      "4. Повторяйте шаги 2-3 до тех пор, пока левая граница не станет больше "
                      "правой или целевой элемент не будет найден.\n"
                      "```python\n"
                      "def binary_search(lst, item):\n    "
                      "low = 0\n    "
                      "high = len(lst) - 1\n\n    "
                      "while low <= high:\n        "
                      "mid = (low + high) // 2\n        "
                      "guess = lst[mid]\n        "
                      "if guess == item:\n            "
                      "return mid\n        "
                      "if guess > item:\n            "
                      "high = mid - 1\n        "
                      "else:\n            "
                      "low = mid + 1\n    "
                      "return None\n\n"
                      "my_list = [1, 3, 5, 7, 9]\n\n"
                      "print(binary_search(my_list, 3))\n"
                      "print(binary_search(my_list, -1))```\n\n"
                      "Этот алгоритм имеет временную сложность O(log n),"
                      " что делает его очень эффективным для поиска в больших отсортированных массивах.",
    "сортировка выбором": "Алгоритм сортировки выбором (или selection sort) — один из простейших"
                          " алгоритмов сортировки. Он работает следующим образом:\n"
                          "1. Инициализация: Исходный массив остается неизменным,"
                          " создаем новый пустой массив sorted_arr.\n"
                          "2. Поиск минимального элемента: Находим минимальный элемент"
                          " в оставшейся неотсортированной части исходного массива.\n"
                          "3. Перенос минимального элемента: Добавляем найденный минимальный элемент"
                          " в sorted_arr и удаляем его из исходного массива.\n"
                          "4. Повторение процесса: Продолжаем шаги 2 и 3, пока исходный массив не станет пустым.\n\n"
                          "```python\n"
                          "def selection_sort(arr):\n    "
                          "sorted_arr = []\n    "
                          "while arr:\n        "
                          "min_value = min(arr)\n        "
                          "sorted_arr.append(min_value)\n        "
                          "arr.remove(min_value)\n    "
                          "return sorted_arr\n\n"
                          "arr = [64, 25, 12, 22, 11]\n"
                          "sorted_arr = selection_sort(arr)\n"
                          "print('Отсортированный массив:', sorted_arr)```\n\n"
                          "Этот алгоритм имеет временную сложность O(n^2), что делает его неэффективным"
                          " для больших массивов, но его просто реализовать и понять.",
    "быстрая сортировка": "Алгоритм быстрой сортировки (QuickSort) — это эффективный алгоритм сортировки,"
                          " применяющий метод 'разделяй и властвуй' - разделение задачи на уменьшающиеся фрагменты.\n"
                          " Алгоритм работает следующим образом:\n\n"
                          "1. Выбор опорного элемента (пивота).\n"
                          "2. Разделение массива вокруг пивота таким образом, чтобы элементы"
                          " меньшие пивота оказались слева, а большие или равные — справа.\n"
                          "3. Рекурсивная сортировка обеих частей.\n"
                          "4. Слияние результатов.\n\n"
                          "```python\n"
                          "import random\n\n"
                          "def quicksort(array):\n    "
                          "if len(array) < 2:\n        "
                          "return array\n    "
                          "else:\n        "
                          "pivot = random.choice(array)\n        "
                          "array.remove(pivot)\n        "
                          "less = [i for i in array if i < pivot]\n        "
                          "greater = [i for i in array if i > pivot]\n        "
                          "return quicksort(less) + [pivot] + quicksort(greater)\n\n"
                          "print(quicksort([10, 5, 2, 3]))```\n\n"
                          "Если брать в качестве опорного элемента случайный элемент из списка то"
                          " средняя скорость выполнения алгоритма будет составлять O(n  log n)",
    "поиск в ширину": "Поиск в ширину (Breadth-First Search, BFS) — это алгоритм для поиска или"
                      " обхода вершин графа. Его особенность заключается в том, что он ищет в ширину,"
                      " т.е. он сначала посещает все соседние узлы уровня перед переходом на следующий уровень.\n\n"
                      "- Очередь — это структуру данных, следуя принципу FIFO (First In, First Out),"
                      " где элементы извлекаются в том порядке, в котором они были добавлены.\n\n"
                      "- В Python для реализации очереди часто используют deque из модуля collections,"
                      "так как она позволяет быстро добавлять и удалять элементы с обеих сторон.\n\n"
                      "Поиск в ширину с использованием очереди:\n"
                      "```python\n"
                      "from collections import deque\n\n"
                      "graph = {}\n\n"
                      "graph['you'] = ['alice', 'bob', 'claire']\n"
                      "graph['bob'] = ['anuj', 'peggy']\n"
                      "graph['alice'] = ['peggy']\n"
                      "graph['claire'] = ['thom', 'jony']\n"
                      "graph['anuj'] = []\n"
                      "graph['peggy'] = []\n"
                      "graph['thom'] = []\n"
                      "graph['jonny'] = []\n\n"
                      "def mango_seller(name):\n    "
                      "return name[-1] == 'm'\n\n"
                      "def search(name):\n    "
                      "search_deque = deque()\n    "
                      "search_deque += graph[name]\n    "
                      "searched = []\n    "
                      "while search_deque:\n        "
                      "person = search_deque.popleft()\n        "
                      "if person not in searched:\n            "
                      "if mango_seller(person):\n                "
                      "print(f'{person} is a mango seller!')\n                "
                      "return True\n            "
                      "else:\n                "
                      "search_deque += graph[person]\n                "
                      "searched.append(person)\n    "
                      "return False\n\n"
                      "search('you')\n"
                      "# вывод: thom is a mango seller!```\n\n"
                      "Пример иллюстрирует поиск человека, который соответствует определённому"
                      " критерию (в данном случае, продавец манго), проходя по всем возможным путям"
                      " в графе начиная с узла 'you'. Благодаря использованию очереди, поиск проходит"
                      " от начального узла по уровням, что делает BFS полезным в таких задачах,"
                      " как кратчайший путь в ненаправленных графах.",
    "алгоритм Дейкстеры": "Алгоритм Дейкстры используется для нахождения кратчайшего пути во взвешанном графе"
                          " от начального узла до всех остальных узлов в графе с неотрицательными весами рёбер.\n\n"
                          "алгоритм Дейкстеры состоит из 4 шагов:\n"
                          "1. Найти узел с наименьшей стоимостью ( до которого можно добраться быстрее всего)\n"
                          "2. Проверить, существует ли более дешевый путь к соседям этого узла,"
                          " и если существует, обновить их стоимости\n"
                          "3. Повторять шаги 1 и 2, пока это не будет сделано для всех узлов графа.\n"
                          "4. Вычислить итоговый путь\n\n"
                          "Пример кода на Python для графа с четырьмя узлами:"
                          "```python\n"
                          "# основной граф\n"
                          "graph = {}\n"
                          "graph['start'] = {}\n"
                          "graph['start']['a'] = 6\n"
                          "graph['start']['b'] = 2\n"
                          "graph['a'] = {}\n"
                          "graph['a']['fin'] = 1\n"
                          "graph['b'] = {}\n"
                          "graph['b']['a'] = 3\n"
                          "graph['b']['fin'] = 5\n"
                          "graph['fin'] = {}\n\n"
                          "# таблица стоимостей узлов\n"
                          "infinity = float('inf')\n"
                          "costs = {}\n"
                          "costs['a'] = 6\n"
                          "costs['b'] = 2\n"
                          "costs['fin'] = infinity\n\n"
                          "# хэш-таблица родителей\n"
                          "parents = {}\n"
                          "parents['a'] = 'start'\n"
                          "parents['b'] = 'start'\n"
                          "parents['in'] = None\n\n"
                          "processed = []\n\n"
                          "def find_lowest_node(costs):\n    "
                          "lowest_cost = float('inf')\n    "
                          "lowest_cost_node = None\n    "
                          "for node in costs:\n        "
                          "cost = costs[node]\n        "
                          "if cost < lowest_cost and node not in processed:\n            "
                          "lowest_cost = cost\n            "
                          "lowest_cost_node = node\n    "
                          "return lowest_cost_node\n\n"
                          "node = find_lowest_node(costs)\n"
                          "while node is not None:\n    "
                          "cost = costs[node]\n    "
                          "neighbors = graph[node]\n    "
                          "for n in neighbors.keys():\n        "
                          "new_cost = cost + neighbors[n]\n        "
                          "if costs[n] > new_cost:\n            "
                          "costs[n] = new_cost\n            "
                          "parents[n] = node\n    "
                          "processed.append(node)\n    "
                          "node = find_lowest_node(costs)\n\n"
                          "print(costs['fin'])  # вывод: 6```\n\n"
                          "Таким образом, этот код находит кратчайший путь от узла"
                          " 'start' до узла 'fin' с использованием алгоритма Дейкстры и выводит его стоимость.",
}
